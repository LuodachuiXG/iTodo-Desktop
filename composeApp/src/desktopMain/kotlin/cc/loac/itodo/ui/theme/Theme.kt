package cc.loac.itodo.ui.theme

import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.*

val greenLightScheme = lightColorScheme(
    primary = primaryGreenLight,
    onPrimary = onPrimaryGreenLight,
    primaryContainer = primaryContainerGreenLight,
    onPrimaryContainer = onPrimaryContainerGreenLight,
    secondary = secondaryGreenLight,
    onSecondary = onSecondaryGreenLight,
    secondaryContainer = secondaryContainerGreenLight,
    onSecondaryContainer = onSecondaryContainerGreenLight,
    tertiary = tertiaryGreenLight,
    onTertiary = onTertiaryGreenLight,
    tertiaryContainer = tertiaryContainerGreenLight,
    onTertiaryContainer = onTertiaryContainerGreenLight,
    error = errorGreenLight,
    onError = onErrorGreenLight,
    errorContainer = errorContainerGreenLight,
    onErrorContainer = onErrorContainerGreenLight,
    background = backgroundGreenLight,
    onBackground = onBackgroundGreenLight,
    surface = surfaceGreenLight,
    onSurface = onSurfaceGreenLight,
    surfaceVariant = surfaceVariantGreenLight,
    onSurfaceVariant = onSurfaceVariantGreenLight,
    outline = outlineGreenLight,
    outlineVariant = outlineVariantGreenLight,
    scrim = scrimGreenLight,
    inverseSurface = inverseSurfaceGreenLight,
    inverseOnSurface = inverseOnSurfaceGreenLight,
    inversePrimary = inversePrimaryGreenLight,
    surfaceDim = surfaceDimGreenLight,
    surfaceBright = surfaceBrightGreenLight,
    surfaceContainerLowest = surfaceContainerLowestGreenLight,
    surfaceContainerLow = surfaceContainerLowGreenLight,
    surfaceContainer = surfaceContainerGreenLight,
    surfaceContainerHigh = surfaceContainerHighGreenLight,
    surfaceContainerHighest = surfaceContainerHighestGreenLight,
)

val greenDarkScheme = darkColorScheme(
    primary = primaryGreenDark,
    onPrimary = onPrimaryGreenDark,
    primaryContainer = primaryContainerGreenDark,
    onPrimaryContainer = onPrimaryContainerGreenDark,
    secondary = secondaryGreenDark,
    onSecondary = onSecondaryGreenDark,
    secondaryContainer = secondaryContainerGreenDark,
    onSecondaryContainer = onSecondaryContainerGreenDark,
    tertiary = tertiaryGreenDark,
    onTertiary = onTertiaryGreenDark,
    tertiaryContainer = tertiaryContainerGreenDark,
    onTertiaryContainer = onTertiaryContainerGreenDark,
    error = errorGreenDark,
    onError = onErrorGreenDark,
    errorContainer = errorContainerGreenDark,
    onErrorContainer = onErrorContainerGreenDark,
    background = backgroundGreenDark,
    onBackground = onBackgroundGreenDark,
    surface = surfaceGreenDark,
    onSurface = onSurfaceGreenDark,
    surfaceVariant = surfaceVariantGreenDark,
    onSurfaceVariant = onSurfaceVariantGreenDark,
    outline = outlineGreenDark,
    outlineVariant = outlineVariantGreenDark,
    scrim = scrimGreenDark,
    inverseSurface = inverseSurfaceGreenDark,
    inverseOnSurface = inverseOnSurfaceGreenDark,
    inversePrimary = inversePrimaryGreenDark,
    surfaceDim = surfaceDimGreenDark,
    surfaceBright = surfaceBrightGreenDark,
    surfaceContainerLowest = surfaceContainerLowestGreenDark,
    surfaceContainerLow = surfaceContainerLowGreenDark,
    surfaceContainer = surfaceContainerGreenDark,
    surfaceContainerHigh = surfaceContainerHighGreenDark,
    surfaceContainerHighest = surfaceContainerHighestGreenDark,
)

val redLightScheme = lightColorScheme(
    primary = primaryRedLight,
    onPrimary = onPrimaryRedLight,
    primaryContainer = primaryContainerRedLight,
    onPrimaryContainer = onPrimaryContainerRedLight,
    secondary = secondaryRedLight,
    onSecondary = onSecondaryRedLight,
    secondaryContainer = secondaryContainerRedLight,
    onSecondaryContainer = onSecondaryContainerRedLight,
    tertiary = tertiaryRedLight,
    onTertiary = onTertiaryRedLight,
    tertiaryContainer = tertiaryContainerRedLight,
    onTertiaryContainer = onTertiaryContainerRedLight,
    error = errorRedLight,
    onError = onErrorRedLight,
    errorContainer = errorContainerRedLight,
    onErrorContainer = onErrorContainerRedLight,
    background = backgroundRedLight,
    onBackground = onBackgroundRedLight,
    surface = surfaceRedLight,
    onSurface = onSurfaceRedLight,
    surfaceVariant = surfaceVariantRedLight,
    onSurfaceVariant = onSurfaceVariantRedLight,
    outline = outlineRedLight,
    outlineVariant = outlineVariantRedLight,
    scrim = scrimRedLight,
    inverseSurface = inverseSurfaceRedLight,
    inverseOnSurface = inverseOnSurfaceRedLight,
    inversePrimary = inversePrimaryRedLight,
    surfaceDim = surfaceDimRedLight,
    surfaceBright = surfaceBrightRedLight,
    surfaceContainerLowest = surfaceContainerLowestRedLight,
    surfaceContainerLow = surfaceContainerLowRedLight,
    surfaceContainer = surfaceContainerRedLight,
    surfaceContainerHigh = surfaceContainerHighRedLight,
    surfaceContainerHighest = surfaceContainerHighestRedLight,
)

val redDarkScheme = darkColorScheme(
    primary = primaryRedDark,
    onPrimary = onPrimaryRedDark,
    primaryContainer = primaryContainerRedDark,
    onPrimaryContainer = onPrimaryContainerRedDark,
    secondary = secondaryRedDark,
    onSecondary = onSecondaryRedDark,
    secondaryContainer = secondaryContainerRedDark,
    onSecondaryContainer = onSecondaryContainerRedDark,
    tertiary = tertiaryRedDark,
    onTertiary = onTertiaryRedDark,
    tertiaryContainer = tertiaryContainerRedDark,
    onTertiaryContainer = onTertiaryContainerRedDark,
    error = errorRedDark,
    onError = onErrorRedDark,
    errorContainer = errorContainerRedDark,
    onErrorContainer = onErrorContainerRedDark,
    background = backgroundRedDark,
    onBackground = onBackgroundRedDark,
    surface = surfaceRedDark,
    onSurface = onSurfaceRedDark,
    surfaceVariant = surfaceVariantRedDark,
    onSurfaceVariant = onSurfaceVariantRedDark,
    outline = outlineRedDark,
    outlineVariant = outlineVariantRedDark,
    scrim = scrimRedDark,
    inverseSurface = inverseSurfaceRedDark,
    inverseOnSurface = inverseOnSurfaceRedDark,
    inversePrimary = inversePrimaryRedDark,
    surfaceDim = surfaceDimRedDark,
    surfaceBright = surfaceBrightRedDark,
    surfaceContainerLowest = surfaceContainerLowestRedDark,
    surfaceContainerLow = surfaceContainerLowRedDark,
    surfaceContainer = surfaceContainerRedDark,
    surfaceContainerHigh = surfaceContainerHighRedDark,
    surfaceContainerHighest = surfaceContainerHighestRedDark,
)


val blueLightScheme = lightColorScheme(
    primary = primaryBlueLight,
    onPrimary = onPrimaryBlueLight,
    primaryContainer = primaryContainerBlueLight,
    onPrimaryContainer = onPrimaryContainerBlueLight,
    secondary = secondaryBlueLight,
    onSecondary = onSecondaryBlueLight,
    secondaryContainer = secondaryContainerBlueLight,
    onSecondaryContainer = onSecondaryContainerBlueLight,
    tertiary = tertiaryBlueLight,
    onTertiary = onTertiaryBlueLight,
    tertiaryContainer = tertiaryContainerBlueLight,
    onTertiaryContainer = onTertiaryContainerBlueLight,
    error = errorBlueLight,
    onError = onErrorBlueLight,
    errorContainer = errorContainerBlueLight,
    onErrorContainer = onErrorContainerBlueLight,
    background = backgroundBlueLight,
    onBackground = onBackgroundBlueLight,
    surface = surfaceBlueLight,
    onSurface = onSurfaceBlueLight,
    surfaceVariant = surfaceVariantBlueLight,
    onSurfaceVariant = onSurfaceVariantBlueLight,
    outline = outlineBlueLight,
    outlineVariant = outlineVariantBlueLight,
    scrim = scrimBlueLight,
    inverseSurface = inverseSurfaceBlueLight,
    inverseOnSurface = inverseOnSurfaceBlueLight,
    inversePrimary = inversePrimaryBlueLight,
    surfaceDim = surfaceDimBlueLight,
    surfaceBright = surfaceBrightBlueLight,
    surfaceContainerLowest = surfaceContainerLowestBlueLight,
    surfaceContainerLow = surfaceContainerLowBlueLight,
    surfaceContainer = surfaceContainerBlueLight,
    surfaceContainerHigh = surfaceContainerHighBlueLight,
    surfaceContainerHighest = surfaceContainerHighestBlueLight,
)

val blueDarkScheme = darkColorScheme(
    primary = primaryBlueDark,
    onPrimary = onPrimaryBlueDark,
    primaryContainer = primaryContainerBlueDark,
    onPrimaryContainer = onPrimaryContainerBlueDark,
    secondary = secondaryBlueDark,
    onSecondary = onSecondaryBlueDark,
    secondaryContainer = secondaryContainerBlueDark,
    onSecondaryContainer = onSecondaryContainerBlueDark,
    tertiary = tertiaryBlueDark,
    onTertiary = onTertiaryBlueDark,
    tertiaryContainer = tertiaryContainerBlueDark,
    onTertiaryContainer = onTertiaryContainerBlueDark,
    error = errorBlueDark,
    onError = onErrorBlueDark,
    errorContainer = errorContainerBlueDark,
    onErrorContainer = onErrorContainerBlueDark,
    background = backgroundBlueDark,
    onBackground = onBackgroundBlueDark,
    surface = surfaceBlueDark,
    onSurface = onSurfaceBlueDark,
    surfaceVariant = surfaceVariantBlueDark,
    onSurfaceVariant = onSurfaceVariantBlueDark,
    outline = outlineBlueDark,
    outlineVariant = outlineVariantBlueDark,
    scrim = scrimBlueDark,
    inverseSurface = inverseSurfaceBlueDark,
    inverseOnSurface = inverseOnSurfaceBlueDark,
    inversePrimary = inversePrimaryBlueDark,
    surfaceDim = surfaceDimBlueDark,
    surfaceBright = surfaceBrightBlueDark,
    surfaceContainerLowest = surfaceContainerLowestBlueDark,
    surfaceContainerLow = surfaceContainerLowBlueDark,
    surfaceContainer = surfaceContainerBlueDark,
    surfaceContainerHigh = surfaceContainerHighBlueDark,
    surfaceContainerHighest = surfaceContainerHighestBlueDark,
)


val yellowLightScheme = lightColorScheme(
    primary = primaryYellowLight,
    onPrimary = onPrimaryYellowLight,
    primaryContainer = primaryContainerYellowLight,
    onPrimaryContainer = onPrimaryContainerYellowLight,
    secondary = secondaryYellowLight,
    onSecondary = onSecondaryYellowLight,
    secondaryContainer = secondaryContainerYellowLight,
    onSecondaryContainer = onSecondaryContainerYellowLight,
    tertiary = tertiaryYellowLight,
    onTertiary = onTertiaryYellowLight,
    tertiaryContainer = tertiaryContainerYellowLight,
    onTertiaryContainer = onTertiaryContainerYellowLight,
    error = errorYellowLight,
    onError = onErrorYellowLight,
    errorContainer = errorContainerYellowLight,
    onErrorContainer = onErrorContainerYellowLight,
    background = backgroundYellowLight,
    onBackground = onBackgroundYellowLight,
    surface = surfaceYellowLight,
    onSurface = onSurfaceYellowLight,
    surfaceVariant = surfaceVariantYellowLight,
    onSurfaceVariant = onSurfaceVariantYellowLight,
    outline = outlineYellowLight,
    outlineVariant = outlineVariantYellowLight,
    scrim = scrimYellowLight,
    inverseSurface = inverseSurfaceYellowLight,
    inverseOnSurface = inverseOnSurfaceYellowLight,
    inversePrimary = inversePrimaryYellowLight,
    surfaceDim = surfaceDimYellowLight,
    surfaceBright = surfaceBrightYellowLight,
    surfaceContainerLowest = surfaceContainerLowestYellowLight,
    surfaceContainerLow = surfaceContainerLowYellowLight,
    surfaceContainer = surfaceContainerYellowLight,
    surfaceContainerHigh = surfaceContainerHighYellowLight,
    surfaceContainerHighest = surfaceContainerHighestYellowLight,
)

val yellowDarkScheme = darkColorScheme(
    primary = primaryYellowDark,
    onPrimary = onPrimaryYellowDark,
    primaryContainer = primaryContainerYellowDark,
    onPrimaryContainer = onPrimaryContainerYellowDark,
    secondary = secondaryYellowDark,
    onSecondary = onSecondaryYellowDark,
    secondaryContainer = secondaryContainerYellowDark,
    onSecondaryContainer = onSecondaryContainerYellowDark,
    tertiary = tertiaryYellowDark,
    onTertiary = onTertiaryYellowDark,
    tertiaryContainer = tertiaryContainerYellowDark,
    onTertiaryContainer = onTertiaryContainerYellowDark,
    error = errorYellowDark,
    onError = onErrorYellowDark,
    errorContainer = errorContainerYellowDark,
    onErrorContainer = onErrorContainerYellowDark,
    background = backgroundYellowDark,
    onBackground = onBackgroundYellowDark,
    surface = surfaceYellowDark,
    onSurface = onSurfaceYellowDark,
    surfaceVariant = surfaceVariantYellowDark,
    onSurfaceVariant = onSurfaceVariantYellowDark,
    outline = outlineYellowDark,
    outlineVariant = outlineVariantYellowDark,
    scrim = scrimYellowDark,
    inverseSurface = inverseSurfaceYellowDark,
    inverseOnSurface = inverseOnSurfaceYellowDark,
    inversePrimary = inversePrimaryYellowDark,
    surfaceDim = surfaceDimYellowDark,
    surfaceBright = surfaceBrightYellowDark,
    surfaceContainerLowest = surfaceContainerLowestYellowDark,
    surfaceContainerLow = surfaceContainerLowYellowDark,
    surfaceContainer = surfaceContainerYellowDark,
    surfaceContainerHigh = surfaceContainerHighYellowDark,
    surfaceContainerHighest = surfaceContainerHighestYellowDark,
)

@Composable
fun ITodoTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable () -> Unit
) {
    var colorScheme by remember {
        mutableStateOf(
            when {
                darkTheme -> greenDarkScheme
                else -> greenLightScheme
            }
        )
    }

    var dark by remember {
        mutableStateOf(darkTheme)
    }

    LaunchedEffect(darkTheme) {
        dark = darkTheme
        when (ThemeFlow.themeFlow.value) {
            "green" -> {
                colorScheme = when {
                    dark -> greenDarkScheme
                    else -> greenLightScheme
                }
            }

            "red" -> {
                colorScheme = when {
                    dark -> redDarkScheme
                    else -> redLightScheme
                }
            }

            "blue" -> {
                colorScheme = when {
                    dark -> blueDarkScheme
                    else -> blueLightScheme
                }
            }

            "yellow" -> {
                colorScheme = when {
                    dark -> yellowDarkScheme
                    else -> yellowLightScheme
                }
            }
        }
    }

    LaunchedEffect(Unit) {
        ThemeFlow.themeFlow.collect {
            when (it) {
                "green" -> {
                    colorScheme = when {
                        dark -> greenDarkScheme
                        else -> greenLightScheme
                    }
                }

                "red" -> {
                    colorScheme = when {
                        dark -> redDarkScheme
                        else -> redLightScheme
                    }
                }

                "blue" -> {
                    colorScheme = when {
                        dark -> blueDarkScheme
                        else -> blueLightScheme
                    }
                }

                "yellow" -> {
                    colorScheme = when {
                        dark -> yellowDarkScheme
                        else -> yellowLightScheme
                    }
                }

            }
        }
    }


    MaterialTheme(
        colorScheme = colorScheme,
        content = content
    )
}
